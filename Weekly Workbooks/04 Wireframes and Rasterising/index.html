<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>04 Wireframes and Rasterising</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">04 Wireframes and Rasterising</h1>
</header>
<h2 id="wireframes-and-rasterising">Wireframes and Rasterising</h2>
<h3 id="weekly-briefing"><a href='https://web.microsoftstream.com/channel/b84051cb-1dba-4cb4-a271-60cc6635f92f' target='_blank'> Weekly Briefing <img src="../../resources/icons/briefing.png" /> </a></h3>
<h3 id="task-1-introduction">Task 1: Introduction</h3>
<p><a href='01%20Introduction/slides/segment-1.pdf' target='_blank'> <img src="../../resources/icons/slides.png" /> </a> <a href='01%20Introduction/audio/segment-1.mp4' target='_blank'> <img src="../../resources/icons/audio.png" /> </a></p>
<p>In this workbook we start to work in 3 dimensions ! Our fundamental objective is to take a 3D model (specified as a bunch of vertices in 3 dimensional space) and attempt to render them as a 2 dimensional image. In order to achieve this, we will make good use of the 2D drawing functions that you have written previously.</p>
<p>Rendering a 3D model onto a 2D image plane requires us to take a particular perspective/viewpoint on that 3D model. To aid in this discussion, we introduce the concept of a <em>camera</em> - take a look at the slides and audio narration above for an explanation of this concept.</p>
<p>To help you in completing this week’s tasks, you have been provided with a <code>ModelTriangle</code> class (found in the libs/sdw folder). This class represents a triangular plane in 3D space and contains variables to hold the positions of its three vertices, as well as the colour of the triangle’s surface. As usual, this class overrides the <code>&lt;&lt;</code> operator so that you can direct it to <code>cout</code> for debugging purposes.</p>
<p>For this workbook, you will need to make use of the <a href="https://en.wikibooks.org/wiki/GLSL_Programming/Vector_and_Matrix_Operations" target="_blank">vec3 and vec4 classes</a> from the GLM library - it might be an idea to become familiar with these now !</p>
<p><strong>Hints &amp; Tips:</strong><br />
<strong>Important</strong>: Make sure you read the “Hints and Tips” at the end of each section before attempting that task. This might save you a lot of time and anguish !</p>
<h1 id="section"></h1>
<h3 id="task-2-reading-obj-geometry-files">Task 2: Reading OBJ Geometry Files</h3>
<p><a href='02%20Reading%20OBJ%20Geometry%20Files/slides/segment-1.pdf' target='_blank'> <img src="../../resources/icons/slides.png" /> </a> <a href='02%20Reading%20OBJ%20Geometry%20Files/audio/segment-1.mp4' target='_blank'> <img src="../../resources/icons/audio.png" /> </a></p>
<p>The first implementation task in this practical is to write a low-level file reader that can parse in 3D models from flat data files. Although the focus of this unit is not on grammars and parsing, understanding how models can be stored in data files provides us with valuable insight into the essential characteristics of 3D geometry and material properties. Check out the slides and audio narration above to find out about the OBJ file format.</p>
<p>Once you are happy with the concepts above, write a function that reads in <a href="models/cornell-box.obj" target="_blank">this sample OBJ geometry file</a> and use the data to populate a vector of <code>ModelTriangles</code>. At this stage, you should only focus on reading in vertices (lines that being with a <code>v</code>) and faces/facets (lines that being with an <code>f</code>). We will deal with the other types of line later on in this workbook.</p>
<p>Once a file has been loaded, loop through all of the triangles in the vector and print them out, (you should be able to send <code>ModelTriangles</code> to <code>cout</code> !) just to make sure they have all been successfully loaded.</p>
<p>Add a scaling factor (float) parameter to the OBJ loading function that scales the position of all vertices at the point at which they are read in from the file. This is done in order to adjust the size of the model when it is loaded (different models will be created to different scales !). This is to avoid the “giant bunny” situation illustrated in the image below, where two models have been loaded in from separate files, but the model of the rabbit just happens to be of a particular large size.</p>
<p><img src="02%20Reading%20OBJ%20Geometry%20Files/images/giant-bunny.png" /></p>
<p><strong>Hints &amp; Tips:</strong><br />
To read in the data from the geometry file, you may like to make use of an <code>ifstream</code> and the <code>getline</code> function. A <code>split</code> function has also been provided (see the <code>Utils</code> class in libs/sdw) to make tokenising of lines easier. But it is really up to you how you parse in the files.</p>
<p>Be careful - remember that faces in OBJ files are indexed from 1 (whereas vectors are indexed from 0).</p>
<p>When loading in the Cornell Box model, we suggest you use a vertex scaling factor of 0.17 since this will bring the all dimensions of the vertices within the range of -1.0 to 1.0 (which seems sensible and logical).</p>
<p>You should keep your parser as simple as possible - remember this unit is about graphical rendering, not parsing data. Only implement the aspects of the OBJ file format that you need to complete the task at hand. Your parser will not be marked - it is just a means to an end (to allow you to incorporate complex models and to provide you with familiarity of geometry storage and retrieval).</p>
<h1 id="section-1"></h1>
<h3 id="task-3-reading-obj-material-files">Task 3: Reading OBJ Material Files</h3>
<p><a href='03%20Reading%20OBJ%20Material%20Files/slides/segment-1.pdf' target='_blank'> <img src="../../resources/icons/slides.png" /> </a> <a href='03%20Reading%20OBJ%20Material%20Files/audio/segment-1.mp4' target='_blank'> <img src="../../resources/icons/audio.png" /> </a></p>
<p>Once you have read in the geometry data, your next job is to write a function to read in <a href="models/cornell-box.mtl" target="_blank">this sample OBJ material file</a> and populate a “palette” of colours. You can use the previously encountered <code>Colour</code> class for this purpose (this is where the <code>name</code> attribute now becomes useful).</p>
<p>You could just use a vector to store the palette of colours or, if you want something a bit fancier, use a hashmap/hashtable for more efficient colour lookup (using the name of the colour as a key).</p>
<p>Once you have successfully loaded the materials file, add some additional code to your geometry parsing function (from the previous task) so that it accesses your colour palette when it encounters a reference to a material (lines that begin with <code>usemtl</code> in the OBJ material file). Note that <code>ModelTriangle</code> objects have a <code>colour</code> attribute that can be used to store a reference to the colour of that triangle.</p>
<p><strong>Hints &amp; Tips:</strong><br />
You should keep your parser as simple as possible - remember this unit is about graphical rendering, not parsing data. Only implement the aspects of the OBJ file format that you need to complete the task at hand. Your parser will not be marked - it is just a means to an end (to allow you to incorporate complex models and to provide you with familiarity of geometry storage and retrieval).</p>
<h1 id="section-2"></h1>
<h3 id="task-4-projecting-onto-the-image-plane">Task 4: Projecting onto the Image Plane</h3>
<p><a href='04%20Projecting%20onto%20the%20Image%20Plane/slides/segment-1.pdf' target='_blank'> <img src="../../resources/icons/slides.png" /> </a> <a href='04%20Projecting%20onto%20the%20Image%20Plane/audio/segment-1.mp4' target='_blank'> <img src="../../resources/icons/audio.png" /> </a> <a href='04%20Projecting%20onto%20the%20Image%20Plane/animation/segment-1.mp4' target='_blank'> <img src="../../resources/icons/animation.png" /> </a></p>
<p>Now that we have geometry and material data loaded, we can attempt to render a graphical representation of this data onto the image plane (i.e. the SDL drawing window). Projecting a vertex onto the image plane is based around the notion of similar triangles. See the slides, narrated audio and animation above for an explanation of this.</p>
<p>Clearly, calculating the projected position of a vertex on the image plane is going to involve the <em>(x,y,z)</em> position of the vertex in 3D space, as well as the distance between the camera and image plane. There is an additional complexity in that the origin of the Cornell Box model is in the centre of the room, whereas the origin of the image plane is at the top left of the drawing window.</p>
<p>When rendering a scene on the 2D image plane, what we really want is for the centre of the room to appear in the <em>centre</em> of the image plane. To achieve this, we just need to shift the 2D position of each vertex before we draw it onto the screen. If we shift everything along by half the width of the image plane and down by half the height of the image plane, the render will appear centred in the middle of the plane. If we didn’t do this, the centre of the room would appear in the top left corner of the drawing window !</p>
<p>The consequence of all of the above discussion is that, for a particular vertex <em>i</em> that has a position in 3D space of <em>(x<sup>i</sup>, y<sup>i</sup>, z<sup>i</sup>)</em> we can calculate its position on the image plane <em>(u<sup>i</sup>, v<sup>i</sup>)</em> using the two formulae provide below (where <em>f</em> is the distance from the camera to the image plane - often referred to as the “focal length”). Note that these formulae assume the vertices are in the <em>camera coordinate system</em> (i.e. the camera is the origin and x, y and z are distances relative to the camera position). The vertices in the OBJ model are however all in the <em>model coordinate system</em> (i.e. relative to the centre of the room). You will need to do a simple transposition in order to convert them from one coordinate system to the other. You will get used to such transpositions in this unit, there are numerous origins we have to cope with !</p>
<p>Use these formulae to project each 3D vertex from the Cornell Box model down onto the 2D image plane. If you draw a single white pixel at each projected point, you should end up with a point-cloud render that looks like the image shown below the formulae. Don’t forget to read the “Hints &amp; Tips” section below before attempting this !</p>
<p><img src="04%20Projecting%20onto%20the%20Image%20Plane/images/01-transpose-to-canvas.png" /></p>
<p><img src="04%20Projecting%20onto%20the%20Image%20Plane/images/02-point-cloud.png" /></p>
<p><strong>Hints &amp; Tips:</strong><br />
In the interests of consistency, you should adopt the convention that positive z is “out of the screen” (towards you) and negative z is “into the screen” (away from you).</p>
<p>When implementing your renderer, you will find it useful to store the position of the camera in a <code>vec3</code> variable. Start by setting your camera position centred in the x and y dimensions, but “stepped back” a bit in the z (by 4.0). Your initial camera position should therefore be <code>(0.0, 0.0, 4.0)</code></p>
<p>You will also need to create a float variable to store the distance of the camera from the image plane (this is the “focal length” mentioned above). This you should initially set to <code>2.0</code> - which makes sense as this would position the image plane halfway between the camera and the model (anywhere else would be a bit crazy really !).</p>
<p>You may find your initial vertex point cloud is a little small - feel free to apply an image plane multiplier to scale the coordinates up so that they fit nicely into the drawing window. Make sure you scale x and y by the same amount (in order to maintain the aspect ratio of the point cloud).</p>
<p>You might find (depending on how you write your code) that your render is upside-down. Any ideas why this might be ?<br />
Any thoughts about how to fix this problem ?</p>
<h1 id="section-3"></h1>
<h3 id="task-5-rendering-wireframes">Task 5: Rendering Wireframes</h3>
<p>Now that you know how to project individual vertices from a 3D model on the image plane, the next step is to produce a “wireframe” render of the Cornell Box model. The basic principle is to create an equivalent 2D <code>CanvasTriangle</code> for each 3D <code>ModelTriangle</code> found in the model. You can then reuse your 2D stroked triangle drawing function that you wrote in the previous workbook to create the final “wireframe” render. If everything works out OK, you should get a wireframe render that looks something like the image below.</p>
<p><img src="05%20Rendering%20Wireframes/images/wireframe.png" /></p>
<h1 id="section-4"></h1>
<h3 id="task-6-rendering-filled-triangles">Task 6: Rendering Filled Triangles</h3>
<p>After you have successfully rendered a wireframe of the model, the next step is to fill those triangles ! This is going to be easier than you might think !!! The image panel is 2D and you have already written a 2D “filled triangle” rasterising function in a previous workbook. Make sure you use the correct colours to fill the triangles (namely the colours that you read in from the materials file and stored in your palette). The end product of drawing the filled triangles of the Cornell Box should look something like the image below.</p>
<p><img src="06%20Rendering%20Filled%20Triangles/images/overlap.png" /></p>
<h1 id="section-5"></h1>
<h3 id="task-7-implementing-a-depth-buffer">Task 7: Implementing a Depth Buffer</h3>
<p><a href='07%20Implementing%20a%20Depth%20Buffer/slides/segment-1.pdf' target='_blank'> <img src="../../resources/icons/slides.png" /> </a> <a href='07%20Implementing%20a%20Depth%20Buffer/audio/segment-1.mp4' target='_blank'> <img src="../../resources/icons/audio.png" /> </a> <a href='07%20Implementing%20a%20Depth%20Buffer/animation/segment-1.mp4' target='_blank'> <img src="../../resources/icons/animation.png" /> </a></p>
<p>You might have noticed a problem with the above image ? Depending on the order in which the triangles appear in an OBJ file, rendered triangles may sometimes overlap each other inappropriately. For example, in the image above, the blue box is shown overlapping the red one - which is not the case in the true model. View the slides and narrated audio above to understand what causes this problem and what we can do to solve it.</p>
<p>In your code, create a 2D array of floats (the dimensions of the array being the same width and height as the image plane). You are going to use this array to keep track of the z depth of the model element drawn for each pixel. The data stored in this “depth buffer” will allow us to decide what colour to paint a pixel when there is contention. It is important that we store the <em><strong>inverse</strong></em> of the z depth of the model element represented. We will explore the reason for this in a future workbook - for the time being you will have to take this on trust (or you could take a look at <a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/visibility-problem-depth-buffer-depth-interpolation" target="_blank">this chapter from scratch-a-pixel</a> if you <em>really</em> can’t wait).</p>
<p>When filling the depth buffer, you will need to calculate the z depth of specific points on the surface of a triangle. It is worth noting that at this point in time you do not actually <em>have</em> depth information for all these points. These depths can however be calculated by interpolating from the depth of known points (i.e. the vertices). Watch the animation linked to at the top of this section for help on achieving this.</p>
<p>Use your depth buffer in your drawing functions to help decide what colour to set a particular image plane pixel. In some cases the first colour you draw a pixel will be the correct one, in other cases this colour will need to be overwritten by a subsequent colour. If your depth buffer is operating correctly, you should see something like the image shown below. Don’t forget to read the “Hints &amp; Tips” section below before attempting this !</p>
<p><img src="07%20Implementing%20a%20Depth%20Buffer/images/overlap-fixed.png" /></p>
<p><img src="07%20Implementing%20a%20Depth%20Buffer/images/z-depth.png" /></p>
<p><strong>Hints &amp; Tips:</strong><br />
Note that the <code>CanvasPoint</code> class has a <code>depth</code> attribute that you might like to use to help you keep track of the z depth of each vertex of a <code>CanvasTriangle</code>.</p>
<p>When you create the depth buffer array you should first initialise every element to zero. This signifies that at the start (before rendering the scene takes place) that there is no model element represented in any pixel position. Another way to think of this is that this value represents 1/Z where Z is infinity (i.e. the distance to the element that has been drawn is infinite - because there isn’t one !).</p>
<p>Because we are using the inverse of the z depth, we must remember that the colour a particular pixel should be drawn must be the model element with the <em>largest</em> 1/Z. Consider the diagram above for example - the pixel on the image plane through which the dotted line passes should clearly be drawn red (since the red triangle is the closest to the camera/eye). However 1/Z for the red triangle (0.5) is <em>greater</em> than that of the blue triangle (0.25). The <em>largest</em> 1/Z always wins !</p>
<h1 id="section-6"></h1>
<h3 id="progress-logbook">Progress Logbook</h3>
<p>It is important to be able to monitor the progress of students as they progress through these workbooks. This is to ensure that everyone is keeping up to date with the work and to identify students who are struggling. For these reasons, it is <strong>ESSENTIAL</strong> that you keep a logbook of progress that you are making. To minimise the overhead in keeping this logbook, you are only required to capture a single screenshot each week (you only need to include the DrawingWindow, not the whole desktop). Try to capture something that summarises the progress that you have made and upload this onto the <a href="https://www.ole.bris.ac.uk/webapps/assignment/uploadAssignment?content_id=_4837989_1&amp;course_id=_240795_1&amp;group_id=&amp;mode=cpview">logbook submission area on blackboard</a>. (Note: you might have to log into blackboard <em>first</em> before your click on this link !). It is important that <strong>EVERYBODY</strong> uploads an image (so we can be sure that everyone is engaging with the unit). If you don’t keep your logbook up to date then you’ll find us getting in touch to see if everything is OK !</p>
</body>
</html>
